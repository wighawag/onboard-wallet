<!DOCTYPE html>
<!-- ERC-107 : https://eips.ethereum.org/EIPS/eip-107 -->
<!-- combined with html-provider.js -->
<html>
  <head>
    <title>Ethereum Authorization</title>
  </head>
  <script>
    //https://github.com/alexvandesande/blockies
    !(function () {
      function r(r) {
        for (var t = 0; t < l.length; t++) l[t] = 0;
        for (var t = 0; t < r.length; t++)
          l[t % 4] = (l[t % 4] << 5) - l[t % 4] + r.charCodeAt(t);
      }
      function t() {
        var r = l[0] ^ (l[0] << 11);
        return (
          (l[0] = l[1]),
          (l[1] = l[2]),
          (l[2] = l[3]),
          (l[3] = l[3] ^ (l[3] >> 19) ^ r ^ (r >> 8)),
          (l[3] >>> 0) / ((1 << 31) >>> 0)
        );
      }
      function e() {
        var r = Math.floor(360 * t()),
          e = 60 * t() + 40 + "%",
          o = 25 * (t() + t() + t() + t()) + "%",
          n = "hsl(" + r + "," + e + "," + o + ")";
        return n;
      }
      function o(r) {
        for (
          var e = r, o = r, n = Math.ceil(e / 2), a = e - n, l = [], c = 0;
          o > c;
          c++
        ) {
          for (var f = [], h = 0; n > h; h++) f[h] = Math.floor(2.3 * t());
          var i = f.slice(0, a);
          i.reverse(), (f = f.concat(i));
          for (var v = 0; v < f.length; v++) l.push(f[v]);
        }
        return l;
      }
      function n(r, t, e, o, n) {
        var a = document.createElement("canvas"),
          l = Math.sqrt(r.length);
        a.width = a.height = l * e;
        var c = a.getContext("2d");
        (c.fillStyle = o),
          c.fillRect(0, 0, a.width, a.height),
          (c.fillStyle = t);
        for (var f = 0; f < r.length; f++) {
          var h = Math.floor(f / l),
            i = f % l;
          (c.fillStyle = 1 == r[f] ? t : n),
            r[f] && c.fillRect(i * e, h * e, e, e);
        }
        return a;
      }
      function a(t) {
        t = t || {};
        var a = t.size || 8,
          l = t.scale || 4,
          c =
            t.seed || Math.floor(Math.random() * Math.pow(10, 16)).toString(16);
        r(c);
        var f = t.color || e(),
          h = t.bgcolor || e(),
          i = t.spotcolor || e(),
          v = o(a),
          u = n(v, f, l, h, i);
        return u;
      }
      var l = new Array(4);
      window.blockies = { create: a };
    })();
  </script>

  <style>
    body {
      font-family: "HelveticaNeue-Light", "Helvetica Neue Light",
        "Helvetica Neue", "Helvetica", "Arial", "Lucida Grande", sans-serif;
      background: #e2e2e2;
    }
    *,
    *:after,
    *:before {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    #pleasewait {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 0;
      margin: 0;
    }
    #infomessage {
      text-align: center;
      font-size: 1rem;
      margin: 0 2rem 4.5rem;
    }

    .wrapper {
      background: #e2e2e2;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 0;
      margin: 0;
      display: none;
      text-align: center;
    }
    .title {
      text-align: center;
      font-size: 1.2rem;
      margin: 1rem 0rem;
    }
    .message {
      text-align: center;
      font-size: 1rem;
      /*margin: 0 2rem 4.5rem;*/
    }

    #passwordField {
      text-align: center;
      font-size: 1rem;
      margin: 1rem 0rem;
      /*margin: 0 2rem 4.5rem;*/
    }

    .wrapper button {
      background: transparent;
      border: none;
      color: #1678e5;
      height: 3rem;
      font-size: 1rem;
      width: 50%;
      position: absolute;
      bottom: 0;
      cursor: pointer;
    }
    #cancel-button {
      border-top: 1px solid #b4b4b4;
      border-right: 1px solid #b4b4b4;
      left: 0;
      border-radius: 0 0 0 10px;
    }
    #confirm-button {
      border-top: 1px solid #b4b4b4;
      right: 0;
      border-radius: 0 0 10px 0;
    }
    .wrapper button:focus,
    .wrapper button:hover {
      font-weight: bold;
      background: #efefef;
    }
    .wrapper button:active {
      background: #d6d6d6;
    }

    .button {
      margin: 1rem 0rem;
      display: inline-block;
      padding: 9px 15px;
      background-color: #3898ec;
      color: white;
      border: 0;
      line-height: inherit;
      text-decoration: none;
      cursor: pointer;
      border-radius: 0;
    }

    input.button {
      -webkit-appearance: button;
    }
  </style>

  <body>
    <div id="pleasewait">
      <br />
      <p id="infomessage">Please wait...</p>
    </div>

    <form id="form" class="wrapper">
      <br />
      <p id="message" class="message"></p>
      <p id="passwordField">
        <label>Password Required:</label><input id="password" type="password" />
      </p>
      <button id="cancel-button" type="button" autofocus>Cancel</button>
      <button id="confirm-button" type="button">Confirm</button>
    </form>

    <div id="modal-dialog" class="wrapper">
      <h3 id="modal-dialog-title" class="title">Title</h3>
      <p id="modal-dialog-message" class="message">Message</p>
      <span id="modal-dialog-button" class="button">Ok</span>
    </div>

    <script>
      let noMessageReceivedYet = true;
      let closedByCode = false;
      const pleaseWait = document.getElementById("pleasewait");
      const form = document.getElementById("form");
      const cancelButton = document.getElementById("cancel-button");
      const confirmButton = document.getElementById("confirm-button");
      const message = document.getElementById("message");
      const infoMessage = document.getElementById("infomessage");
      const password = document.getElementById("password");
      const passwordField = document.getElementById("passwordField");
      const modalDialog = document.getElementById("modal-dialog");
      const modalDialogButton = document.getElementById("modal-dialog-button");
      const modalDialogTitle = document.getElementById("modal-dialog-title");
      const modalDialogMessage = document.getElementById(
        "modal-dialog-message"
      );

      let firstUrl = null;

      let inIframe = true;
      let source = null;
      if (window.opener) {
        inIframe = false;
        source = window.opener;
      } else if (window.parent != window) {
        source = window.parent;
      } else {
        console.log("closing");
        window.close();
      }

      if (!inIframe) {
        setTimeout(checkMessageNotReceived, 1000);
      } else {
        showWaiting("accepting request...");
      }

      if (source) {
        source.postMessage("ready", "*");
      }

      window.addEventListener("message", receiveMessage);

      function receiveMessage(event) {
        if (event.source != source) {
          return;
        }
        if (firstUrl) {
          if (firstUrl != event.origin) {
            return;
          }
        } else {
          firstUrl = event.origin;
        }
        hideMessage();
        noMessageReceivedYet = false;
        const data = event.data;
        try {
          processMessage(data, event.source);
        } catch (e) {
          event.source.postMessage(
            {
              id: data.id,
              result: null,
              error: { message: "Could not process message data" },
              type: "notValid",
            },
            firstUrl
          );
          showMessage(
            "Error",
            "The application has sent invalid data",
            function () {
              closeWindow();
            }
          );
        }
      }

      function checkMessageNotReceived() {
        if (noMessageReceivedYet) {
          showMessage(
            "Error",
            "No transaction received. Please make sure popup are not blocked.",
            function () {
              closeWindow();
            }
          );
        }
      }

      function closeWindow() {
        closedByCode = true;
        window.close();
      }

      function showWaiting(text) {
        if (!text) {
          text = "Please wait...";
        }
        infoMessage.innerHTML = text;
        pleaseWait.style.display = "block";
        form.style.display = "none";
      }

      function hideWaiting() {
        pleaseWait.style.display = "none";
        form.style.display = "block";

        window.onbeforeunload = null;
      }

      function showMessage(title, message, callback, buttonText) {
        modalDialog.style.display = "block";
        modalDialogTitle.innerHTML = title;
        modalDialogMessage.innerHTML = "";
        if (typeof message == "string") {
          modalDialogMessage.innerHTML += message;
        } else {
          modalDialogMessage.appendChild(message);
        }
        modalDialogMessage.appendChild(document.createElement("br"));

        if (!buttonText) {
          buttonText = "Ok";
        }
        modalDialogButton.innerHTML = buttonText;
        modalDialogButton.onclick = function () {
          modalDialogButton.onclick = null;
          modalDialog.style.display = "none";
          if (callback) {
            callback();
          }
        };
      }

      function hideMessage() {
        modalDialog.style.display = "none";
        modalDialogButton.onclick = null;
      }

      function sendAsync(url, payload, callback) {
        const request = new XMLHttpRequest();
        request.open("POST", url, true);
        request.setRequestHeader("Content-Type", "application/json");

        request.onreadystatechange = function () {
          if (request.readyState === 4) {
            const result = request.responseText;
            const error = null;
            try {
              result = JSON.parse(result);
            } catch (e) {
              const message =
                !!result && !!result.error && !!result.error.message
                  ? result.error.message
                  : "Invalid JSON RPC response: " + JSON.stringify(result);
              error = { message: message, type: "JsonParse" };
            }
            callback(error, result);
          }
        };

        try {
          request.send(JSON.stringify(payload));
        } catch (e) {
          callback({
            message: "CONNECTION ERROR: Couldn't connect to node " + url + ".",
            type: "noConnection",
          });
        }
      }

      function addBlocky(message, address) {
        const icon = blockies.create({
          seed: address,
          size: 8,
          scale: 6,
        });
        message.appendChild(icon);
      }

      function askAuthorization(
        transactionInfo,
        data,
        requireUnlock,
        sourceWindow
      ) {
        const valueAsHex = transactionInfo["value"]
          ? transactionInfo.value
          : "0x0";
        const gasProvidedAsHex = transactionInfo.gas;
        const gasPriceProvidedAsHex = transactionInfo.gasPrice;
        const gasPrice = BigInt(gasPriceProvidedAsHex);
        const gas = BigInt(gasProvidedAsHex);
        const weiValue = BigInt(valueAsHex);
        const gasWeiValue = gas * gasPrice;
        const etherValue = weiValue / 1000000000000000000n;

        const gasEtherValue = gasWeiValue / 1000000000000000000n;

        hideWaiting();

        message.innerHTML = "";

        addBlocky(message, transactionInfo.from);

        const span = document.createElement("span");
        span.style = "font-size:3em;";
        span.innerHTML =
          "&nbsp;&nbsp;&nbsp;" + "&#x2192;" + "&nbsp;&nbsp;&nbsp;";
        message.appendChild(span);

        addBlocky(message, transactionInfo.to);

        message.appendChild(document.createElement("br"));
        const textSpan = document.createElement("span");
        message.appendChild(textSpan);
        textSpan.innerHTML =
          etherValue.toFormat() +
          " ether <br/>  + gas cost (" +
          gasEtherValue.toFormat() +
          " ether )";

        if (requireUnlock) {
          passwordField.style.display = "block";
        } else {
          passwordField.style.display = "none";
        }

        cancelButton.onclick = function () {
          sourceWindow.postMessage(
            {
              id: data.id,
              result: null,
              error: { message: "Not Authorized" },
              type: "cancel",
            },
            firstUrl
          );
          closeWindow();
        };

        const submitFunc = function () {
          window.onbeforeunload = function (event) {
            if (!closedByCode) {
              return "do not close now as a transaction is progress, this cannot be canceled and we wait for an answer";
            }
          };
          if (requireUnlock) {
            if (password.value == "") {
              password.style.border = "2px solid red";
              return false;
            }
            password.style.border = "none";
            const params = [transactionInfo.from, password.value, 3];
            showWaiting("Please wait...<br/>Do not close the window.");
            sendAsync(
              data.url,
              { id: 999992, method: "personal_unlockAccount", params: params },
              function (error, result) {
                if (error || result.error) {
                  showMessage(
                    "Error unlocking account",
                    "Please retry.",
                    hideWaiting
                  );
                } else {
                  sendAsync(data.url, data.payload, function (error, result) {
                    sourceWindow.postMessage(
                      { id: data.id, result: result, error: error },
                      firstUrl
                    );
                    closeWindow();
                  });
                }
              }
            );
          } else {
            sendAsync(data.url, data.payload, function (error, result) {
              if (result && result.error) {
                processMessage(data, sourceWindow);
              } else {
                sourceWindow.postMessage(
                  { id: data.id, result: result, error: error },
                  firstUrl
                );
                closeWindow();
              }
            });
            showWaiting();
          }
          return false;
        };

        form.onsubmit = submitFunc;
        confirmButton.onclick = submitFunc;
      }

      function needToAndCanUnlockAccount(address, url, callback) {
        sendAsync(
          url,
          {
            id: 9999990,
            method: "eth_sign",
            params: [
              address,
              "0xc6888fa8d57087278718986382264244252f8d57087278718986382264244252f",
            ],
          },
          function (error, result) {
            if (error || result.error) {
              sendAsync(
                url,
                { id: 9999991, method: "personal_listAccounts", params: [] },
                function (error, result) {
                  if (error || result.error) {
                    callback(true, false);
                  } else {
                    callback(true, true);
                  }
                }
              );
            } else {
              callback(false);
            }
          }
        );
      }

      const allowedMethods = [
        "web3_clientVersion",
        "web3_sha3",
        "net_version",
        "net_peerCount",
        "net_listening",
        "eth_protocolVersion",
        "eth_syncing",
        "eth_coinbase",
        "eth_mining",
        "eth_hashrate",
        "eth_gasPrice",
        "eth_accounts",
        "eth_blockNumber",
        "eth_getBalance",
        "eth_getStorageAt",
        "eth_getTransactionCount",
        "eth_getBlockTransactionCountByHash",
        "eth_getBlockTransactionCountByNumber",
        "eth_getUncleCountByBlockHash",
        "eth_getUncleCountByBlockNumber",
        "eth_getCode",
        "eth_sendRawTransaction",
        "eth_call",
        "eth_estimateGas",
        "eth_getBlockByHash",
        "eth_getBlockByNumber",
        "eth_getTransactionByHash",
        "eth_getTransactionByBlockHashAndIndex",
        "eth_getTransactionByBlockNumberAndIndex",
        "eth_getTransactionReceipt",
        "eth_getUncleByBlockHashAndIndex",
        "eth_getUncleByBlockNumberAndIndex",
        "eth_getCompilers",
        "eth_compileLLL",
        "eth_compileSolidity",
        "eth_compileSerpent",
        "eth_newFilter",
        "eth_newBlockFilter",
        "eth_newPendingTransactionFilter",
        "eth_uninstallFilter",
        "eth_getFilterChanges",
        "eth_getFilterLogs",
        "eth_getLogs",
        "eth_getWork",
        "eth_submitWork",
        "eth_submitHashrate",
        // ,"shh_post"
        // ,"shh_version"
        // ,"shh_newIdentity"
        // ,"shh_hasIdentity"
        // ,"shh_newGroup"
        // ,"shh_addToGroup"
        // ,"shh_newFilter"
        // ,"shh_uninstallFilter"
        // ,"shh_getFilterChanges"
        // ,"shh_getMessages"
      ];

      function isMethodAllowed(method) {
        return allowedMethods.indexOf(method) != -1;
      }

      function processMessage(data, sourceWindow) {
        if (inIframe) {
          if (isMethodAllowed(data.payload.method)) {
            sendAsync(data.url, data.payload, function (error, result) {
              sourceWindow.postMessage(
                { id: data.id, result: result, error: error },
                firstUrl
              );
            });
          } else {
            sourceWindow.postMessage(
              {
                id: data.id,
                result: null,
                error: {
                  message:
                    "method (" +
                    data.payload.method +
                    ") not allowed in iframe",
                },
                type: "notAllowed",
              },
              firstUrl
            );
          }
        } else if (data.payload.method == "eth_sendTransaction") {
          const transactionInfo = null;
          if (data.payload.params.length > 0) {
            if (
              data.payload.params[0]["gas"] &&
              data.payload.params[0]["gasPrice"] &&
              data.payload.params[0]["to"] &&
              data.payload.params[0]["from"]
            ) {
              transactionInfo = data.payload.params[0];
            }
          }
          if (transactionInfo != null) {
            needToAndCanUnlockAccount(
              transactionInfo.from,
              data.url,
              function (requireUnlock, canUnlock) {
                if (requireUnlock && canUnlock) {
                  askAuthorization(transactionInfo, data, true, sourceWindow);
                } else if (!requireUnlock) {
                  askAuthorization(transactionInfo, data, false, sourceWindow);
                } else if (requireUnlock && !canUnlock) {
                  const messageHtml = document.createElement("span");
                  addBlocky(messageHtml, transactionInfo.from);
                  messageHtml.appendChild(document.createElement("br"));
                  const span = document.createElement("span");
                  span.innerHTML =
                    "You need to unlock your account first : <br/>" +
                    transactionInfo.from;
                  messageHtml.appendChild(span);

                  showMessage(
                    "Account Locked",
                    messageHtml,
                    function () {
                      processMessage(data, sourceWindow);
                    },
                    "Done"
                  );
                }
              }
            );
          } else {
            sourceWindow.postMessage(
              {
                id: data.id,
                result: null,
                error: {
                  message: "Need to specify from , to, gas and gasPrice",
                },
                type: "notValid",
              },
              firstUrl
            );
            closeWindow();
          }
        } else {
          sourceWindow.postMessage(
            {
              id: data.id,
              result: null,
              error: {
                message:
                  "method (" + data.payload.method + ") not allowed in popup",
              },
              type: "notAllowed",
            },
            firstUrl
          );
        }
      }
    </script>
  </body>
</html>
