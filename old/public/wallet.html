<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OnBoard Wallet</title>

    <link rel="stylesheet" href="picocss/pico.classless.min.css" />
    <link rel="stylesheet" href="style.css" />

    <script src="blockies.js"></script>
  </head>

  <body>
    <header id="pleasewait" style="display: none">
      <p id="infomessage">Please wait...</p>
    </header>

    <form id="form" style="display: none">
      <p id="message"></p>
      <p id="passwordField">
        <label for="password">
          Password Required:
          <input id="password" type="password" />
        </label>
      </p>
      <button id="cancel-button" type="button" autofocus>Cancel</button>
      <button id="confirm-button" type="button">Confirm</button>
    </form>

    <dialog id="modal-dialog">
      <article>
        <header id="modal-dialog-title">
          <!-- <a href="#close" aria-label="Close" class="close"></a> -->
          Title
        </header>
        <p id="modal-dialog-message">Message</p>
        <footer>
          <!-- <a href="#cancel" role="button" class="secondary">Cancel</a> -->
          <a id="modal-dialog-button" href="#confirm" role="button">OK</a>
        </footer>
      </article>
    </dialog>

    <script>
      let noMessageReceivedYet = true;
      let closedByCode = false;
      const pleaseWait = document.getElementById("pleasewait");
      const form = document.getElementById("form");
      const cancelButton = document.getElementById("cancel-button");
      const confirmButton = document.getElementById("confirm-button");
      const message = document.getElementById("message");
      const infoMessage = document.getElementById("infomessage");
      const password = document.getElementById("password");
      const passwordField = document.getElementById("passwordField");
      const modalDialog = document.getElementById("modal-dialog");
      const modalDialogButton = document.getElementById("modal-dialog-button");
      const modalDialogTitle = document.getElementById("modal-dialog-title");
      const modalDialogMessage = document.getElementById(
        "modal-dialog-message"
      );

      let firstUrl = null;

      let inIframe = true;
      let source = null;
      if (window.opener) {
        inIframe = false;
        source = window.opener;
      } else if (window.parent != window) {
        source = window.parent;
      } else {
        console.log("closing");
        window.close();
      }

      if (!inIframe) {
        setTimeout(checkMessageNotReceived, 1000);
      } else {
        showWaiting("accepting request...");
      }

      if (source) {
        source.postMessage("ready", "*");
      }

      window.addEventListener("message", receiveMessage);

      function receiveMessage(event) {
        if (event.source != source) {
          return;
        }
        if (firstUrl) {
          if (firstUrl != event.origin) {
            return;
          }
        } else {
          firstUrl = event.origin;
        }
        hideMessage();
        noMessageReceivedYet = false;
        const data = event.data;
        try {
          processMessage(data, event.source);
        } catch (e) {
          event.source.postMessage(
            {
              id: data.id,
              result: null,
              error: { message: "Could not process message data" },
              type: "notValid",
            },
            firstUrl
          );
          showMessage(
            "Error",
            "The application has sent invalid data",
            function () {
              closeWindow();
            }
          );
        }
      }

      function checkMessageNotReceived() {
        if (noMessageReceivedYet) {
          showMessage(
            "Error",
            "No transaction received. Please make sure popup are not blocked.",
            function () {
              closeWindow();
            }
          );
        }
      }

      function closeWindow() {
        closedByCode = true;
        window.close();
      }

      function showWaiting(text) {
        if (!text) {
          text = "Please wait...";
        }
        infoMessage.innerHTML = text;
        pleaseWait.style.display = "block";
        form.style.display = "none";
      }

      function hideWaiting() {
        pleaseWait.style.display = "none";
        form.style.display = "block";

        window.onbeforeunload = null;
      }

      function showMessage(title, message, callback, buttonText) {
        modalDialog.open = true;
        modalDialogTitle.innerHTML = title;
        modalDialogMessage.innerHTML = "";
        if (typeof message == "string") {
          modalDialogMessage.innerHTML += message;
        } else {
          modalDialogMessage.appendChild(message);
        }
        modalDialogMessage.appendChild(document.createElement("br"));

        if (!buttonText) {
          buttonText = "Ok";
        }
        modalDialogButton.innerHTML = buttonText;
        modalDialogButton.onclick = function () {
          modalDialogButton.onclick = null;
          modalDialog.style.display = "none";
          if (callback) {
            callback();
          }
        };
      }

      function hideMessage() {
        modalDialog.style.display = "none";
        modalDialogButton.onclick = null;
      }

      function sendAsync(url, payload, callback) {
        const request = new XMLHttpRequest();
        request.open("POST", url, true);
        request.setRequestHeader("Content-Type", "application/json");

        request.onreadystatechange = function () {
          if (request.readyState === 4) {
            const result = request.responseText;
            const error = null;
            try {
              result = JSON.parse(result);
            } catch (e) {
              const message =
                !!result && !!result.error && !!result.error.message
                  ? result.error.message
                  : "Invalid JSON RPC response: " + JSON.stringify(result);
              error = { message: message, type: "JsonParse" };
            }
            callback(error, result);
          }
        };

        try {
          request.send(JSON.stringify(payload));
        } catch (e) {
          callback({
            message: "CONNECTION ERROR: Couldn't connect to node " + url + ".",
            type: "noConnection",
          });
        }
      }

      function addBlocky(message, address) {
        const icon = blockies.create({
          seed: address,
          size: 8,
          scale: 6,
        });
        message.appendChild(icon);
      }

      function askAuthorization(
        transactionInfo,
        data,
        requireUnlock,
        sourceWindow
      ) {
        const valueAsHex = transactionInfo["value"]
          ? transactionInfo.value
          : "0x0";
        const gasProvidedAsHex = transactionInfo.gas;
        const gasPriceProvidedAsHex = transactionInfo.gasPrice;
        const gasPrice = BigInt(gasPriceProvidedAsHex);
        const gas = BigInt(gasProvidedAsHex);
        const weiValue = BigInt(valueAsHex);
        const gasWeiValue = gas * gasPrice;
        const etherValue = weiValue / 1000000000000000000n;

        const gasEtherValue = gasWeiValue / 1000000000000000000n;

        hideWaiting();

        message.innerHTML = "";

        addBlocky(message, transactionInfo.from);

        const span = document.createElement("span");
        span.style = "font-size:3em;";
        span.innerHTML =
          "&nbsp;&nbsp;&nbsp;" + "&#x2192;" + "&nbsp;&nbsp;&nbsp;";
        message.appendChild(span);

        addBlocky(message, transactionInfo.to);

        message.appendChild(document.createElement("br"));
        const textSpan = document.createElement("span");
        message.appendChild(textSpan);
        textSpan.innerHTML =
          etherValue.toFormat() +
          " ether <br/>  + gas cost (" +
          gasEtherValue.toFormat() +
          " ether )";

        if (requireUnlock) {
          passwordField.style.display = "block";
        } else {
          passwordField.style.display = "none";
        }

        cancelButton.onclick = function () {
          sourceWindow.postMessage(
            {
              id: data.id,
              result: null,
              error: { message: "Not Authorized" },
              type: "cancel",
            },
            firstUrl
          );
          closeWindow();
        };

        const submitFunc = function () {
          window.onbeforeunload = function (event) {
            if (!closedByCode) {
              return "do not close now as a transaction is progress, this cannot be canceled and we wait for an answer";
            }
          };
          if (requireUnlock) {
            if (password.value == "") {
              password.style.border = "2px solid red";
              return false;
            }
            password.style.border = "none";
            const params = [transactionInfo.from, password.value, 3];
            showWaiting("Please wait...<br/>Do not close the window.");
            sendAsync(
              data.url,
              { id: 999992, method: "personal_unlockAccount", params: params },
              function (error, result) {
                if (error || result.error) {
                  showMessage(
                    "Error unlocking account",
                    "Please retry.",
                    hideWaiting
                  );
                } else {
                  sendAsync(data.url, data.payload, function (error, result) {
                    sourceWindow.postMessage(
                      { id: data.id, result: result, error: error },
                      firstUrl
                    );
                    closeWindow();
                  });
                }
              }
            );
          } else {
            sendAsync(data.url, data.payload, function (error, result) {
              if (result && result.error) {
                processMessage(data, sourceWindow);
              } else {
                sourceWindow.postMessage(
                  { id: data.id, result: result, error: error },
                  firstUrl
                );
                closeWindow();
              }
            });
            showWaiting();
          }
          return false;
        };

        form.onsubmit = submitFunc;
        confirmButton.onclick = submitFunc;
      }

      function needToAndCanUnlockAccount(address, url, callback) {
        sendAsync(
          url,
          {
            id: 9999990,
            method: "eth_sign",
            params: [
              address,
              "0xc6888fa8d57087278718986382264244252f8d57087278718986382264244252f",
            ],
          },
          function (error, result) {
            if (error || result.error) {
              sendAsync(
                url,
                { id: 9999991, method: "personal_listAccounts", params: [] },
                function (error, result) {
                  if (error || result.error) {
                    callback(true, false);
                  } else {
                    callback(true, true);
                  }
                }
              );
            } else {
              callback(false);
            }
          }
        );
      }

      const allowedMethods = [
        "web3_clientVersion",
        "web3_sha3",
        "net_version",
        "net_peerCount",
        "net_listening",
        "eth_protocolVersion",
        "eth_syncing",
        "eth_coinbase",
        "eth_mining",
        "eth_hashrate",
        "eth_gasPrice",
        "eth_accounts",
        "eth_blockNumber",
        "eth_getBalance",
        "eth_getStorageAt",
        "eth_getTransactionCount",
        "eth_getBlockTransactionCountByHash",
        "eth_getBlockTransactionCountByNumber",
        "eth_getUncleCountByBlockHash",
        "eth_getUncleCountByBlockNumber",
        "eth_getCode",
        "eth_sendRawTransaction",
        "eth_call",
        "eth_estimateGas",
        "eth_getBlockByHash",
        "eth_getBlockByNumber",
        "eth_getTransactionByHash",
        "eth_getTransactionByBlockHashAndIndex",
        "eth_getTransactionByBlockNumberAndIndex",
        "eth_getTransactionReceipt",
        "eth_getUncleByBlockHashAndIndex",
        "eth_getUncleByBlockNumberAndIndex",
        "eth_getCompilers",
        "eth_compileLLL",
        "eth_compileSolidity",
        "eth_compileSerpent",
        "eth_newFilter",
        "eth_newBlockFilter",
        "eth_newPendingTransactionFilter",
        "eth_uninstallFilter",
        "eth_getFilterChanges",
        "eth_getFilterLogs",
        "eth_getLogs",
        "eth_getWork",
        "eth_submitWork",
        "eth_submitHashrate",
        // ,"shh_post"
        // ,"shh_version"
        // ,"shh_newIdentity"
        // ,"shh_hasIdentity"
        // ,"shh_newGroup"
        // ,"shh_addToGroup"
        // ,"shh_newFilter"
        // ,"shh_uninstallFilter"
        // ,"shh_getFilterChanges"
        // ,"shh_getMessages"
      ];

      function isMethodAllowed(method) {
        return allowedMethods.indexOf(method) != -1;
      }

      function processMessage(data, sourceWindow) {
        if (inIframe) {
          if (isMethodAllowed(data.payload.method)) {
            sendAsync(data.url, data.payload, function (error, result) {
              sourceWindow.postMessage(
                { id: data.id, result: result, error: error },
                firstUrl
              );
            });
          } else {
            sourceWindow.postMessage(
              {
                id: data.id,
                result: null,
                error: {
                  message:
                    "method (" +
                    data.payload.method +
                    ") not allowed in iframe",
                },
                type: "notAllowed",
              },
              firstUrl
            );
          }
        } else if (data.payload.method == "eth_sendTransaction") {
          const transactionInfo = null;
          if (data.payload.params.length > 0) {
            if (
              data.payload.params[0]["gas"] &&
              data.payload.params[0]["gasPrice"] &&
              data.payload.params[0]["to"] &&
              data.payload.params[0]["from"]
            ) {
              transactionInfo = data.payload.params[0];
            }
          }
          if (transactionInfo != null) {
            needToAndCanUnlockAccount(
              transactionInfo.from,
              data.url,
              function (requireUnlock, canUnlock) {
                if (requireUnlock && canUnlock) {
                  askAuthorization(transactionInfo, data, true, sourceWindow);
                } else if (!requireUnlock) {
                  askAuthorization(transactionInfo, data, false, sourceWindow);
                } else if (requireUnlock && !canUnlock) {
                  const messageHtml = document.createElement("span");
                  addBlocky(messageHtml, transactionInfo.from);
                  messageHtml.appendChild(document.createElement("br"));
                  const span = document.createElement("span");
                  span.innerHTML =
                    "You need to unlock your account first : <br/>" +
                    transactionInfo.from;
                  messageHtml.appendChild(span);

                  showMessage(
                    "Account Locked",
                    messageHtml,
                    function () {
                      processMessage(data, sourceWindow);
                    },
                    "Done"
                  );
                }
              }
            );
          } else {
            sourceWindow.postMessage(
              {
                id: data.id,
                result: null,
                error: {
                  message: "Need to specify from , to, gas and gasPrice",
                },
                type: "notValid",
              },
              firstUrl
            );
            closeWindow();
          }
        } else {
          sourceWindow.postMessage(
            {
              id: data.id,
              result: null,
              error: {
                message:
                  "method (" + data.payload.method + ") not allowed in popup",
              },
              type: "notAllowed",
            },
            firstUrl
          );
        }
      }
    </script>
  </body>
</html>
